DROP TABLE ROLES CASCADE CONSTRAINTS;
CREATE TABLE ROLES (
	id INTEGER PRIMARY KEY,
	role VARCHAR2(50) UNIQUE NOT NULL
);

DROP TABLE USERS CASCADE CONSTRAINTS;
CREATE TABLE USERS (
	-- Syntax for columns
	-- column_name TYPE CONSTRAINTS
	id INTEGER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
	-- The GENERATED BY DEFAULT ON NULL AS IDENTITY portion
	-- simply declares that this column may have its values
	-- automatically generated
	-- Which is quite convenient for our primary keys
	-- This phrase (For OracleSQL) will create a SEQUENCE and a TRIGGER on this table
	-- in order to accomodate the auto-increment
	-- The SEQUENCE will start at 1, and increase by 1 at a time
	-- And the TRIGGER will grab a value from the sequence if
	-- a record gets inserted without a primary key
	username VARCHAR2(50) UNIQUE NOT NULL CHECK (LENGTH(username) > 2),
	-- VARCHAR2 is the standard type we use for strings
	-- the 50 is the maximum length
	-- We can have a CHECK constraint to enforce that usernames are at least
	-- 3 letters in length
	password VARCHAR2(50) NOT NULL,
	first_name VARCHAR2(50) NOT NULL,
	last_name VARCHAR2(50) NOT NULL,
	email VARCHAR2(100) UNIQUE NOT NULL CHECK (email LIKE '_%@_%._%'),
	role_id INTEGER NOT NULL REFERENCES ROLES (id)
	-- FK Syntax: column_name TYPE REFERENCES TABLE (column_name)
	-- The constraints that are placed on the above foreign key
	-- determine the "multiplicity"/"cardinality" of the relationship
	-- If this foreign key is UNIQUE, that means the relationship
	-- will be 1 to 1
	-- Otherwise, the relationship will be 1 to many
);
-- User1 1, matthew, 	password, 	Matthew, 	Oberlies, 	matthew.oberlies@revature.com, 	1
-- User2 2, larry, 		pass, 		Larry, 		Beaver, 	larry.beaver@revature.com, 		1

/*
 * Multiplicity or Cardinality are the numerical relationship
 * between tables
 * Three kinds:
 * 1 to 1
 * 1 to many (or many to 1)
 * many to many
 * 
 * many to many relationships are structured differently
 * Using what is called a "Join Table"
 */

DROP TABLE ACCOUNT_STATUS CASCADE CONSTRAINTS;
CREATE TABLE ACCOUNT_STATUS (
	id INTEGER PRIMARY KEY,
	status VARCHAR2(50) UNIQUE NOT NULL
);

DROP TABLE ACCOUNT_TYPE CASCADE CONSTRAINTS;
CREATE TABLE ACCOUNT_TYPE (
	id INTEGER PRIMARY KEY,
	type VARCHAR2(50) UNIQUE NOT NULL
);

DROP TABLE ACCOUNTS CASCADE CONSTRAINTS;
CREATE TABLE ACCOUNTS (
	id INTEGER GENERATED BY DEFAULT ON NULL AS IDENTITY PRIMARY KEY,
	balance NUMBER(22, 2) DEFAULT 0 NOT NULL,
	status_id INTEGER NOT NULL REFERENCES ACCOUNT_STATUS (id),
	type_id INTEGER NOT NULL REFERENCES ACCOUNT_TYPE (id)
);

/*
 * The way Join Tables work is that we create an entirely separate
 * table that will track both sides of the relationship
 * 
 * This table will have 2 foreign keys, each to one of the tables in
 * the relationship
 * And each of these foreign keys will be not unique
 * so that we effectively are tying two "1 to many" relationships together
 * 
 * 1 to many - many to 1
 */

DROP TABLE USERS_ACCOUNTS CASCADE CONSTRAINTS;
CREATE TABLE USERS_ACCOUNTS (
	user_id INTEGER NOT NULL,
	account_id INTEGER NOT NULL,
	
	CONSTRAINT users_accounts_pk PRIMARY KEY (user_id, account_id),
	-- Syntax: CONSTRAINT constraint_name CONSTRAINT_TYPE (columns)
	CONSTRAINT user_id_fk FOREIGN KEY (user_id) REFERENCES USERS (id),
	CONSTRAINT account_id_fk FOREIGN KEY (account_id) REFERENCES ACCOUNTS (id)
);
